<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hub Routes</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <!-- <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/bundle.js"></script> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litepicker/dist/css/litepicker.css"/>

    <link href="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css" type="text/css">

    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="header">

    </div>

    <div class="map-container">
        

        <div class="filter-section">
            <!-- <img src="icons/logo_img.png" alt="" height="auto" width="80%"> -->

            <div class="form" id="form">

                <div class="d-flex geocoder-container">
                    <div id="geocoder" class="geocoder"></div>
                    <div id="geocoder-dest" class="geocoder-dest"></div>
                </div>

                <div class="post-section">
                    <!-- <div class="input-group">
                        <label for="bedrooms">Bedrooms</label>
                        <input type="number" class="form-control" id="bedrooms" placeholder="Bedroom Count ...">
                    </div>

                    <div class="input-group">
                        <label for="inventory">Inventory Items</label>
                        <input type="file" class="form-control" id="inventory" placeholder="Files ...">
                    </div> -->

                    <!-- Customer (shipper) enters
                        date range, 
                        number of bedrooms, 
                        optionally inputting an itemized inventory 
                        uploading images/videos for improved accuracy) 
                        submits a “post” to our load board. -->
                </div>

                <div class="filters d-none">
                    <!-- origin -->
                    <div class="input-group">
                        <label for="origin">Origin</label>
                        <input type="text" class="form-control" id="origin" placeholder="Search Zipcode ...">

                        <div class="suggestions" id="origin-results">
                            <!-- <div class="">Origin</div> -->
                        </div>
                    </div>

                    <!-- destination -->
                    <div class="input-group">
                        <label for="destination">Destination</label>
                        

                        <input type="text" class="form-control" id="destination" placeholder="Search Zipcode ...">

                        <div class="suggestions" id="destination-results">
                            <!-- <div class="">Destination</div> -->
                        </div>

                    </div>

                </div>
                
                <!-- date range -->
                <div class="input-group">
                    <label for="date-range">Date Range</label>
                    <input data-name="date-range" id="date-range" class="form-control"/>
                </div>

                <!-- <div>
                    <div class="input-group">
                        <button type="submit" class="search-btn" id="submit-button"> Search </button>
                    </div>
                </div> -->

                
            </div>

            <div class="listing-section">
                <table>
                    <thead>
                        <th>From</th>
                        <th>To</th>
                        <th></th>
                    </thead>

                    <tbody id="listing-table">

                    </tbody>
                </table>
            </div>  

            <button type="submit" class="search-btn d-none" id="submit-button"> Post </button>

            <div class="submit-section">
                <button type="submit" class="search-btn" id="post-button"> Post </button>
                <button type="submit" class="search-btn" id="reserve-button"> Reserve </button>
            </div>

        </div>

        <div id="map">
            <div class="reset-btn" id="reset-btn">Reset Button</div>

            <div class="legend-container">
                <div class="section-title">Legend</div>

                <div class="legend-body">
                    <div class="legend-item">
                        <div class="color-div" style="background-color: black;"></div>
                        <div>Origin</div>
                    </div>

                    <div class="legend-item">
                        <div class="color-div" style="background-color: green;"></div>
                        <div>Destination</div>
                    </div>
                </div>
            </div>
        </div>

        <a id="downloadAnchorElem" style="display:none"></a>


        <!-- User Contact Information -->
        <div id="myModal" class="modal">

            <!-- Modal content -->
            <div class="modal-content">
              <span class="close">&times;</span>
              <h3>Register To Continue</h3>

              <form action="/" method="post">
                <div class="input-group">
                    <label for="first-name">First Name</label>
                    <input type="text" data-name="first-name" id="first-name" class="form-control"/>
                </div>

                <div class="input-group">
                    <label for="last-name">Last Name</label>
                    <input type="text" data-name="last-name" id="last-name" class="form-control"/>
                </div>

                <div class="input-group">
                    <label for="phone-number">Phone Number</label>
                    <input type="text" data-name="phone-number" id="phone-number" class="form-control"/>
                </div>

                <div class="input-group">
                    <label for="email">Email</label>
                    <input type="email" data-name="email" id="email" class="form-control"/>
                </div>

                <div class="input-group">
                    <button type="submit" class="search-btn" id="register-button">Register</button>
                </div>

              </form>

              <!-- First name, Last name, phone number, email.  -->
            </div>
          
          </div>
    </div>
    

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.12.0/mapbox-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/litepicker.js"></script>

    <script src="d3.js"></script>
    <script src='turf.min.js'></script>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoiZGF1ZGk5NyIsImEiOiJjanJtY3B1bjYwZ3F2NGFvOXZ1a29iMmp6In0.9ZdvuGInodgDk7cv-KlujA';
        
        // colors
        let colors = [
            '#88CCEE', '#CC6677', '#DDCC77', '#117733', '#332288', '#AA4499', 
            '#44AA99', '#999933', '#882255', '#661100', '#6699CC', '#888888', '#f6edbd'
        ];

        // let colors = ['#3d5941', '#778868', '#b5b991', '#f6edbd', '#edbb8a', '#de8a5a', '#ca562c', '#008080', '#70a494', '#b4c8a8', '#f6edbd', '#edbb8a', '#de8a5a', '#ca562c'];
        
        let places = [
            {"Id":0,"Name":"Miami","Lat":25.7824664,"Lon":-80.5000894 }, {"Id":1,"Name":"Atlanta","Lat":33.7675738,"Lon":-84.5602184},
            {"Id":2,"Name":"Chicago","Lat":41.8339042,"Lon":-88.0121592}, {"Id":3,"Name":"New York","Lat":40.6976701,"Lon":-74.259877},
            {"Id":4,"Name":"Dallas","Lat":32.8209296,"Lon":-97.0117533}, {"Id":5,"Name":"Los Angeles","Lat":34.0207305,"Lon":-118.6919326},
            {"Id":6,"Name":"San Francisco","Lat":37.757815,"Lon":-122.5076408}, {"Id":7,"Name":"Seattle","Lat":47.6131746,"Lon":-122.4821502},
            {"Id":8,"Name":"Portland","Lat":45.5428688,"Lon":-122.7944872}, {"Id":9,"Name":"Pheonix","Lat":33.470882,"Lon":-112.3561069},
            {"Id":10,"Name":"Denver","Lat":39.7254496,"Lon":-105.0583699}, {"Id":11,"Name":"Nashville","Lat":36.15650908,"Lon":-86.77887538},
            {"Id":12,"Name":"Charlotte","Lat":35.225353,"Lon":-80.89115}
        ];
        
        let routingInstance, popupItem;
        let originMarkers = [], destinationMarkers = [], statesMarkers, statesEntries;

        const map = new mapboxgl.Map({
            container: 'map', // container ID
            style: 'mapbox://styles/mapbox/light-v11', // style URL
            center: [-99.16265728992448, 39.073482949062736], // starting position [lng, lat]
            projection:'mercator',
            zoom: 3.2 // starting zoom
        });

        map.addControl(new mapboxgl.NavigationControl(), 'top-right');

        map.on("load", () => {
            let lineColors = getRouteExpression();

            map.addSource("states", {
                type:"geojson",
                data:"states.geojson"
            });

            map.addLayer({
                id:"states",
                source:"states",
                type:"line",
                paint:{
                    "line-color":"#222",
                    // "line-outline-color":"#fff",
                    "line-opacity":0.3
                }
            }, "");

            map.addSource("route", {
                type:'geojson',
                data:{"type":"FeatureCollection", "features":[] }
                // data:'data.json'
            });

            map.addLayer({
                id:'route-line-case',
                source:'route',
                type:'line',
                paint:{
                    "line-color":[
                        'match',
                        ['get','selected'],
                        'true',
                        'gold',
                        'false',
                        '#555',
                        '#555'
                    ],
                    "line-width":3.5
                }
            });

            map.addLayer({
                id:'route-line',
                source:'route',
                type:'line',
                paint:{
                    "line-color":['get', 'color'],
                    "line-width":1.9
                }
            });

            // sources
            map.addSource("mover-locations", {
                type:'geojson',
                data:{ "type":"FeatureCollection", "features":[] }
            });

            map.addLayer({
                id:'mover-locations',
                type:'circle',
                source:'mover-locations',
                paint:{
                    'circle-color':'#314356',
                    'circle-stroke-color':'#666',
                    'circle-stroke-width':1,
                    'circle-opacity':0.6,
                    'circle-radius':[
                        'interpolate',
                        ['linear'],
                        ['get', 'count'],
                        0,
                        5,
                        20,
                        10
                    ]
                }
            });

            map.on("mouseover", "mover-locations", (e) => {

                if(e.features[0]) {
                    let place = e.features[0];

                    
                    popupItem = new mapboxgl.Popup({ focusAfterOpen:false });
                    popupItem
                        .setLngLat(e.lngLat)
                        .setHTML(`<div class="popup-content">
                            <div class="popup-title">${place.properties.origin_address }</div>
                        </div>`)
                        .addTo(map);
                }
                
                handelMouseover();
            });
            map.on("mouseleave",  "mover-locations", handelMouseleave);

            map.on("mouseover", "states", handelMouseover);
            map.on("mouseleave",  "mover-locations", handelMouseleave);

            function handelMouseover() {  map.getCanvas().style.cursor= "pointer"; }
            function handelMouseleave() {  map.getCanvas().style.cursor= ""; popupItem.remove(); }
            
            // user routes
            map.addSource('user-route', {
                type:'geojson',
                data:{"type":"FeatureCollection", "features":[]}
            });

            map.addLayer({
                id:'user-route-case',
                source:'user-route',
                type:"line",
                paint:{
                    "line-color":"blue",
                    "line-width":4
                }
            });

            map.addLayer({
                id:'user-route',
                source:'user-route',
                type:"line",
                paint:{
                    "line-color":"red",
                    "line-width":2.5
                }
            });


            // read the csv file
            d3.csv('truck_routes.csv')
            .then(data => {
                // console.log(data);
                data = data.slice(0, -1);

                let uniqueLocations = getUniqueLocations(data);
                map.getSource('mover-locations').setData(uniqueLocations);

                // route data
                fetch('data.json')
                    .then(res => res.json())
                    .then(dataRoute => {

                        dataRoute.features = dataRoute.features.map(ft => {
                            let entry = data.find(item => item.fid == ft.properties.fid);

                            if(entry) {
                                ft.properties = { ...ft.properties, ...entry };
                            }

                            return ft;
                        });

                        routingInstance = new RoutingAlgo(map, [...data]);
                        routingInstance.routesGeojson = dataRoute;


                    })
                    .catch(console.error);

                // renderMarkers(data);

                updateSelectionOptions(data);
                // renderListingSections(data);

                updateStatesData(data);

            }).catch(console.error);

        });


        function getUniqueLocations(data) {
            let entries = data.reduce((a, b) => {
                let entry = a.find(item => item['origin_address'] == b['origin_address']);

                if(entry) {
                    entry.count += 1;
                } else {
                    a.push({ ...b, count:1 });
                }

                return a;
            }, []);

            let features = entries.map(item => turf.point([item.origin_x, item.origin_y], {...item}));

            return turf.featureCollection([...features]);
        }


        function renderMarkers(places) {
            console.log(places);

            // originMarkers.forEach(mkr => mkr.remove())
            // originMarkers = places.map(place => {
            //     return createMarker(place, 'origin');
            // });

           
            destinationMarkers.forEach(mkr => mkr.remove())
            destinationMarkers = places.map(place => {
                return createMarker(place, 'dest');
            });
        }


        function createMarker(place, prefix) {
            let markerElement = document.createElement("div");
            markerElement.className = `div-marker ${prefix}-marker`;

            markerElement.style.backgroundColor = `${routeColor(place)}`;

            let popup = new mapboxgl.Popup({ focusAfterOpen:false });
            popup.setHTML(`<div class="popup-content">
                <div class="popup-title">${prefix == 'origin' ? place.origin_address : place.to_address}</div>
            </div>`);

            let marker = new mapboxgl.Marker({element:markerElement});
            marker.id = place.fid;

            marker
                .setLngLat([parseFloat(place[`${prefix}_x`]), parseFloat(place[`${prefix}_y`])])
                .setPopup(popup)
                .addTo(map)

            return marker;
        }

        function getRouteExpression() {
            let placesCount = places.length;
            
            let stops = places.map((place) => {
                return [place.Id, colors[place.Id]]
            }).reduce((a, b) => [...a, ...b], []);

            // console.log(stops);

            return [
                'interpolate',
                ['linear'],
                ['get', 'route_id'],
                ...stops
            ];
        }

        function routeColor(place) {
            return colors[parseFloat(place.fid)] || "black";
        }


        // update origin destination
        function updateSelectionOptions(data) {
            let originAddresses = [...new Set(data.map(item=> item.origin_address))];

            // let originOptions = originAddresses.map(item => {
            //     return `<option value="origin-${item}">${item}</option>`;
            // });

            document.getElementById("origin").oninput = (e) => {
                let { value } = e.target;

                console.log(value);

                let results = filterRoutesData(data, 'origin', value);
                renderResultListing(results, 'origin');
            }

            let destAddresses = [...new Set(data.map(item=> item.to_address))];
            // let destOptions = destAddresses.map(item => {
            //     return `<option value="dest-${item}">${item}</option>`;
            // });

            document.getElementById("destination").oninput = (e) => {
                let { value } = e.target;

                let results = filterRoutesData(data, 'destination', value);
                renderResultListing(results, 'destination');
            }

        }

        function filterRoutesData(data, type, value) {
            let valueStr = value.toLocaleLowerCase();

            if(!value) return [];

            if(type == "origin") {
                return data.filter(entry => {
                    let address = entry.origin_address.toLocaleLowerCase();

                    if(address.includes(valueStr)) {
                        return entry;
                    } 

                    return false;
                });

            } else {
                return data.filter(entry => {
                    let address = entry.to_address.toLocaleLowerCase();

                    if(address.includes(valueStr)) {
                        return entry;
                    } 

                    return false;
                });
            }
        }

        function renderResultListing(result, elementId) {
            let resultsContainer = document.getElementById(`${elementId}-results`);
            resultsContainer.innerHTML = "";

            let field = elementId == 'origin' ? 'origin_address' : 'to_address';

            // results
            result.slice(0, 10).forEach(item => {
                let card = document.createElement("div");
                card.className = "card-item";
                card.dataset.id = elementId;

                card.innerHTML = `${item[field]}`;

                card.onclick = (e) => {
                    console.log(item);
                    let { dataset : { id } } = e.target;
                    console.log(id);

                    let field = id == 'origin' ? 'origin_address' : 'to_address';

                    let coords = id == 'origin' ? 
                        [parseFloat(item.origin_x), parseFloat(item.origin_y)] : 
                        [parseFloat(item.dest_x), parseFloat(item.dest_y)];

                    // map.flyTo({
                    //     center:[...coords],
                    //     zoom:10
                    // });

                    document.getElementById(id).value = item[field];

                    // close the collapse  section
                    e.target.parentElement.innerHTML = "";

                    let values = id == 'origin' ? 
                        [document.getElementById(id).value, document.getElementById("destination").value] :
                        [document.getElementById("origin").value, document.getElementById(id).value];


                    // filter routes data
                    filterRoutes(
                        [...values], 
                        id
                    );

                    
                };

                // filter routes
                resultsContainer.append(card);

            });

        }

        function renderListingSections(data) {

            let cards = data.map(entry => {
                let textColor = entry.color ? entry.color : "#222";
                console.log(textColor);

                return `<tr id="entry-${entry.fid}" data-fid="${entry.fid}" style="color:${textColor} !important; " class="route-rows" >
                    <td data-fid="${entry.fid}">
                        <span class="">${entry.origin_address}</span>
                    </td>

                    <td data-fid="${entry.fid}">
                        <span class="">${entry.to_address}</span>
                    </td>

                    <td data-fid="${entry.fid}">
                        <div class="map-pin" id="${entry.fid}">
                            <img src="icons/placeholder.svg" alt="location-icon"/>
                        </div>
                    </td>
                </tr>`;
            });


            document.getElementById("listing-table").innerHTML = cards.join("");

            setTimeout(() => {
                document.querySelectorAll(".map-pin").forEach(btn => {
                    btn.onclick = (e) => {
                        console.log(e.target.id);   

                        routingInstance.hightlightRoute()

                        let marker = originMarkers.find(mkr => mkr.id == e.target.id);

                        if(marker) {
                            marker.togglePopup();
                            map.flyTo({center:marker.getLngLat(), zoom:8});
                        }
                        
                    };
                });

                handleTableRowHover();

            }, 3000);
            
        }

        function handleTableRowHover() {
            let rows = document.querySelectorAll(".route-rows");

            console.log(rows);

            rows.forEach(rowElement => {
                rowElement.addEventListener("mouseover", (e) => {

                    console.log(e.target.dataset);
                    let { dataset: { fid } } = e.target;

                    routingInstance.hightlightRoute(fid);

                });

            });

        }

        function changeListeners() {
            document.getElementById("origin").onchange = (e) => {
                console.log(e.target.value);
                let { value } = e.target;

                let fid = value.split("-")[1];
                let destId = document.getElementById("destination").value.split("-")[1];
                filterRoutes(
                    [fid, destId], 
                    'origin'
                );
            };

            document.getElementById("destination").onchange = (e) => {
                console.log(e.target.value);
                let { value } = e.target;

                let fid = value.split("-")[1];
                let originId = document.getElementById("origin").value.split("-")[1];

                filterRoutes(
                    [originId, fid], 
                    'destination'
                );


            };

        }

        changeListeners();

        function filterRoutes(pointIds, type) {
            console.log(pointIds);

            let features = [...routingInstance.routesGeojson.features];

            if(!pointIds[0] && !pointIds[1]) {
                features = [];
            };

            if( pointIds[1]) {
                features = features.filter(feature => {
                    return feature.properties.to_address == pointIds[1];
                });
            }

            if( pointIds[0]) { 
                
                let STUSPS = "78660, TX,United States".split(",")[1].replace(" ", "");
                filterStatesMarkers(STUSPS);

                features = features.filter(feature => {
                    return feature.properties.origin_address == pointIds[0];
                });
            }

            let fc = turf.featureCollection([...features]);
            map.getSource('route').setData(fc);
        }

        function updateStatesData(data) {
            fetch('states_centroids.geojson')
                .then(res => res.json())
                .then(statesData => {
                    console.log(statesData);

                    statesEntries = {...statesData};

                    statesData.features = statesData.features.map(state => {
                        let entries = data.filter(item => item.From === state.properties.STUSPS);

                        state.properties.entries = [...entries];

                        return state;
                    });


                    // map.getSource("states").setData(statesData).;
                    console.log(statesData);

                    // renderStatesMarkers(statesData);
                })
                .catch(console.error)
        }

        function renderStatesMarkers(statesFc) {
            statesMarkers = statesFc.features.map(state => {
                let customElement = document.createElement("div");
                customElement.className = "states-marker";

                customElement.innerHTML = `<div>${state.properties.entries.length}</div>`;

                customElement.onclick = (e) => {
                    console.log(e);

                    // display the route and the marker on the given locations
                    let { STUSPS, entries } = state.properties;


                    // renderMarkers([ ...entries ]);
                    routingInstance.places = [...entries];

                    routingInstance.filterRoutes([...entries]);

                    filterStatesMarkers(STUSPS);
                    
                }

                let marker = new mapboxgl.Marker({element:customElement});
                marker.setLngLat(state.geometry.coordinates).addTo(map);
                marker.id = state.properties.STUSPS;


                return marker;
            })
        }

        function filterStatesMarkers(STUSPS) {
            statesMarkers.forEach(marker => {
                if(marker.id == STUSPS) {
                    marker.addTo(map);
                } else {
                    marker.remove();
                }

            });

            let entries = statesEntries.features.find(feature => feature.properties.STUSPS === STUSPS);
            // renderMarkers([...entries.properties.entries]);
        }


        document.getElementById("reset-btn").onclick = (e) => {
            resetVisual();
        }

        function resetVisual() {
            if(statesMarkers) { statesMarkers.forEach(marker => { marker.addTo(map) }); }
            
            routingInstance.places = [];
            routingInstance.createRoutes();

            console.log("Removing markers");
            destinationMarkers.forEach(marker => { marker.remove() });
            originMarkers.forEach(marker => { marker.remove() });

            renderListingSections([]);
            map.getSource("user-route").setData({...turf.featureCollection([])});
        }

        // create a routing class
        class RoutingAlgo {
            constructor(map, places) {
                this.map = map;
                this.places = places;
                this.filteredRoutes;

                this.statesBorder = [];

                d3.csv("states.csv")
                    .then(res => {
                        console.log(res);

                        this.statesBorder = [...res.slice(0, -1)]
                    })
            }

            randomRouteEndpoints() {
                let count = this.places.length;

                this.routes = {};

                this.places.forEach(place => {
                    let destinationCount = Math.round(Math.random() * 8 + 1);

                    // console.log(place.Name);
                    this.routes[place.Name] = {...place};
                    this.routes[place.Name].destination = this.places.slice(0, destinationCount).filter(item => item.Name !== place.Name);
                
                }); 
                
                console.log(this.routes);

                return this;
            }

            filterRoutes(items) {
                // console.log(items);
                // console.log(this.routesGeojson);

                let features = this.routesGeojson.features.filter(feature => {
                    let entry = items.find(item => item.fid == feature.properties.fid);

                    if(entry) {
                        return feature;
                    } else {
                        return false;
                    }
                });

                // console.log(features);

                this.map.getSource('route').setData(turf.featureCollection([...features]));
            }

            createRoutes() {
                // this.routesGeojson = turf.featureCollection([]);

                // let features = Object.values(this.places).map(entry => {
                //     let routes =  this.createRoute({...entry})
                    
                //     return routes;
                // });
               

               let fc  = turf.featureCollection([]);
                this.map.getSource("route").setData({...fc});
                // this.iterateRequest([...this.places]);

            }

            createRoute(entry) {
                let origin_coords = [parseFloat(entry.origin_x), parseFloat(entry.origin_y)];
                let dest_coords = [parseFloat(entry.dest_x), parseFloat(entry.dest_y)];

                var start = turf.point([...origin_coords]);
                var end = turf.point([...dest_coords]);

                var greatCircle = turf.greatCircle(start, end, { 
                    properties: { 
                        name: `${entry.origin_address} to ${entry.to_address}`,
                        route_id :parseInt(entry.fid),
                        ...entry
                    }
                });

                return greatCircle;
            }


            renderRoutes() {
                if(this.map.loaded()) {
                    this.map.getSource("route").setData({...this.routesGeojson});
                } else {
                    this.map.once("load", (e) => {
                        this.map.getSource("route").setData({...this.routesGeojson})
                    });
                }
                
            }

            iterateRequest(entries) {
                // console.log(entries);

                let count = entries.length;
                let i = 0;

                let iter = (entry)  => {
                    let destination = [entry.dest_x, entry.dest_y ];
                    let origin =  [entry.origin_x, entry.origin_y ];

                    this.requestRoute(
                        origin, destination, 
                        { ...entry },
                        callbackFn
                    );
                }

                const callbackFn = (result)  => {
                    // console.log(result);

                    this.routesGeojson.features = [...this.routesGeojson.features, ...result];
                    this.renderRoutes();

                    // move to the next origin
                    // console.log("Moving to origin");
                    i++;

                    if(i < count) {
                        iter(entries[i]);
                    } else {
                        this.storeAndDownloadRoutes();
                    }
                    
                }

                iter(entries[0]);

            }


            // request the routes from mapbox routing api;
            requestRoute(origin, destination, originObj, cb) {
               let url = `https://api.mapbox.com/directions/v5/mapbox/driving/${origin};${destination}?access_token=${mapboxgl.accessToken}&geometries=geojson`
                
               return fetch(url)
                .then(res => res.json())
                .then(data => {
                    let { routes } = data;
                    let features = routes.map(route => {

                        return {
                            "type":"Feature",
                            "geometry":{...route.geometry},
                            "properties":{...originObj}
                        }

                    });

                    cb(features);

                    // return features;
                })
                .catch(console.error)
            }

            storeAndDownloadRoutes() {
                var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.routesGeojson));

                var dlAnchorElem = document.getElementById('downloadAnchorElem');
                dlAnchorElem.setAttribute("href",     dataStr     );
                dlAnchorElem.setAttribute("download", "data.json");
                dlAnchorElem.click();
            }

            findClosestAvailableRoute(route, destination, origin) {
                let routeBuffer = turf.buffer(route, 0, {units: 'miles'});
                console.log(routeBuffer);

                // check if the route has similar origin and destination as the user route.
                let dest_name = destination.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    destination.place_name.toLocaleLowerCase();

                // destination.place_name.toLocaleLowerCase();
                let origin_name = origin.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    origin.place_name.toLocaleLowerCase();

                // state routes
                let routesFeatures = this.routesGeojson.features.filter(feature => {
                    let destState = feature.properties['To State'].toLocaleLowerCase();
                    let originState = feature.properties['From State'].toLocaleLowerCase();

                    if(dest_name.includes(destState) && origin_name.includes(originState)) {
                        feature.properties.color = "green";

                        return feature;
                    }

                    return false;
                });

                console.log(JSON.parse(JSON.stringify(routesFeatures)));

                // routes with similar destination and direction
                let borderStatesFeatures = this.routesGeojson.features.filter(feature => {
                    let destState = feature.properties['To State'].toLocaleLowerCase();

                    let originState = feature.properties['From State'].toLocaleLowerCase();
                    let borderStates = this.statesBorder.find(item => item.State.trim().toLocaleLowerCase() == originState)|| {Borders:""};
                    let destinationBorderStates = this.statesBorder.find(item => item.State.trim().toLocaleLowerCase() == destState) || {Borders:""};

                    if(!borderStates) {
                        return false;
                    }

                    console.log(borderStates);
                    if(dest_name.includes(destState) && borderStates.Borders.toLocaleLowerCase().includes(origin_name)) {
                        feature.properties.color = "orange";

                        return feature;
                    }

                    if(origin_name.includes(originState) && destinationBorderStates.Borders.toLocaleLowerCase().includes(dest_name)) {
                        feature.properties.color = "orange";

                        return feature;
                    }

                    return false;
                });

                // routes on the same direction
               
                if(routesFeatures) {
                    routesFeatures = [...routesFeatures, ...borderStatesFeatures];

                    console.log(routesFeatures);

                    
                    this.map.getSource('route').setData(turf.featureCollection([...routesFeatures]));
                }
               
            }

            colorRoutesByStates(origin, destination) {
                 // check if the route has similar origin and destination as the user route.
                 let dest_name = destination.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    destination.place_name.toLocaleLowerCase();

                // destination.place_name.toLocaleLowerCase();
                let origin_name = origin.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    origin.place_name.toLocaleLowerCase();

                this.filteredRoutes = this.filteredRoutes.map(feature => {
                    let destState = feature.properties['To State'].toLocaleLowerCase();
                    let originState = feature.properties['From State'].toLocaleLowerCase();

                    if(dest_name.includes(destState) && origin_name.includes(originState)) {
                        feature.properties.color = "green";
                    } else {
                        feature.properties.color = "orange";
                    }

                    return feature;
                }).sort((a, b) => a.properties.color.length - b.properties.color.length);

                this.map.getSource('route').setData(turf.featureCollection([...this.filteredRoutes]));
            }

            filterRouteByDestination(destination) {
                // destination.place_name.toLocaleLowerCase();
                let destination_name = destination.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    destination.place_name.toLocaleLowerCase();

                console.log(destination_name);
                let fc = this.filterRoutesWithinBuffer(destination, 'dest');

                this.map.getSource('route').setData(fc);

                renderMarkers([...fc.features.map(ft => ft.properties)]);
            }


            filterRouteByOrigin(origin) {
                // destination.place_name.toLocaleLowerCase();
                let origin_name = origin.context.find(ctx => ctx.id.includes('region')).text.toLocaleLowerCase() || 
                    origin.place_name.toLocaleLowerCase();

                let fc = this.filterRoutesWithinBuffer(origin, 'origin');
                this.map.getSource('route').setData(fc);

                renderMarkers([...fc.features.map(ft => ft.properties)]);
            }

            filterRoutesByDate(dates) {
                let features = this.filteredRoutes ? this.filteredRoutes : this.routesGeojson.features;

                let [ minDate, maxDate ] = dates;

                // features = features.filter(ft => {
                //     if(ft.properties.date > minDate && ft.properties.date < maxDate) {
                //         return ft;
                //     }

                //     return false;
                // });

                // this.map.getSource('route').setData( {...turf.featureCollection([...features]) } );
            }

            renderResultRoutes() {
                renderListingSections([...this.filteredRoutes.map(route => route.properties)]);
            }

            filterRoutesWithinBuffer(position, prefix) {
                let features = this.filteredRoutes ? this.filteredRoutes : this.routesGeojson.features;
                let buffer = turf.buffer(turf.point([...position.center]), 500, { units: 'miles' });

                // state routes
                let routesFeatures = features.filter(feature => {
                    let point = turf.point([ feature.properties[`${prefix}_x`], feature.properties[`${prefix}_y`] ]);

                    let booleanCrosses = turf.booleanPointInPolygon(point, buffer);

                    if(booleanCrosses) {
                        feature.properties.color = "#333";

                        return feature;
                    }

                    feature.properties.selected = "false";

                    return false;
                });

                
                this.filteredRoutes = [...routesFeatures];

                return turf.featureCollection([...routesFeatures]);
            }

            hightlightRoute(fid) {
                this.filterRoutes = this.filteredRoutes.map(route => {
                    if(route.properties.fid == fid) {
                        route.properties.selected = "true";
                    } else {
                        route.properties.selected = "false";
                    }

                    return route;
                });

                
                console.log(fid);
                this.map.getSource('route').setData({ "type":"FeatureCollection", "features": [...this.filteredRoutes] });
            }

        }


        // custom direction api
        class CustomDirectionAPI {
            constructor(map) {

                this.map = map;
                this.destinationResult;
                this.originResult;
                this.submitButton = document.getElementById("submit-button");

                // geocoder
                this.geocoder = new MapboxGeocoder({
                    accessToken: mapboxgl.accessToken,
                    mapboxgl: mapboxgl,
                    countries:'us',
                    types:'postcode,address,place,poi',
                    flyTo:false,
                    marker:false,
                    placeholder:'Origin ...'
                });
                
                document.getElementById('geocoder').appendChild(this.geocoder.onAdd(this.map));

                // destination class
                this.geocoderDest = new MapboxGeocoder({
                    accessToken: mapboxgl.accessToken,
                    mapboxgl: mapboxgl,
                    countries:'us',
                    types:'postcode,address,place,poi',
                    flyTo:false,
                    marker:false,
                    placeholder:'Destination ...'
                });

                // "country", "region", "postcode", "district", "place", "locality", "neighborhood", "address", "poi", or "poi.landmark".

                document.getElementById('geocoder-dest').appendChild(this.geocoderDest.onAdd(this.map));


                // datepicker
                this.picker = new Litepicker({
                    element: document.getElementById('date-range'),
                    singleMode: false,
                    setup:(picker) => {
                        picker.on("selected", (date1, date2) => {
                            // console.log("Updated the files");
                            console.log(date1, date2);

                            // update the date
                            let dates = [date1, date2];

                            if(this.originResult && this.destinationResult) { 
                                this.computeRoutes();

                                
                                routingInstance.colorRoutesByStates(this.originResult, this.destinationResult);
                                routingInstance.renderResultRoutes();
                            }

                            routingInstance.filterRoutesByDate(dates);

                        });
                    }
                });
            }

            fireEventListers() {

                // get the results
                this.geocoder.on("result", ({ result }) => {
                    console.log("origin");
                    console.log(result);

                    this.originResult = {...result};
                    routingInstance.filterRouteByOrigin(result);

                    // if(this.destinationResult) { this.computeRoutes() }
                });

                this.geocoderDest.on("result", ({ result }) => {
                    console.log("Destination");
                    console.log(result);

                    this.destinationResult = {...result};

                    routingInstance.filterRouteByDestination(result)
                });

                this.geocoder.on("clear", (e) => { 
                    this.originResult = undefined;
                    resetVisual(); 

                    routingInstance.filteredRoutes = null;

                    if(this.destinationResult) {
                        routingInstance.filterRouteByDestination(this.destinationResult);
                    }

                });

                this.geocoderDest.on("clear", (e) => { 
                    this.destinationResult = undefined;
                    resetVisual(); 

                    routingInstance.filteredRoutes = null;

                    if(this.originResult) { 
                        routingInstance.filterRouteByOrigin(this.originResult);
                    }

                });

                this.submitButton.onclick = (e) => {
                    console.log("Submit Click");

                    // fire the search aspect
                    if(this.originResult && this.destinationResult) { 
                        this.computeRoutes(); 
                    }

                }

                this.layerTogglers = document.querySelectorAll(".")

            }


            computeRoutes() {
                let origin = this.originResult.center.toString();
                let destination = this.destinationResult.center.toString();

                console.log(origin);

                
                let url = `https://api.mapbox.com/directions/v5/mapbox/driving/${origin};${destination}?access_token=${mapboxgl.accessToken}&geometries=geojson`
                
                fetch(url)
                    .then(res => res.json())
                    .then(data => {
                        let { routes } = data;  

                        let features = routes.map(route => {

                        return {
                            "type":"Feature",
                            "geometry":{...route.geometry},
                            "properties":{
                                origin:this.originResult.place_name, 
                                destination:this.destinationResult.place_name
                            }
                        };

                    });

                    console.log(features);

                    this.userRoute = turf.featureCollection([...features]);

                    map.getSource('user-route').setData({ ...this.userRoute });

                    // routingInstance.findClosestAvailableRoute(this.userRoute, this.destinationResult, this.originResult);
                    // return features;
                })
                .catch(console.error)
            }
        }

        const customDirection = new CustomDirectionAPI(map);
        customDirection.fireEventListers();


        /* 
            TO DO:
            - On hover aspect:table hightlight the route;
            - Post and Reserve Logic
            - Refresh Logic
            - Remove Table and Submit section (When no route are not shown)
            - Handle No route founds
            - Zoom in to route bounds
            - Filter Movers locations source
            - Flexible date options: Months and weekend, 1 week,  2 weeks
        */ 

        function ModalContainer() {
            // Get the modal
            var modal = document.getElementById("myModal");

            // Get the button that opens the modal
            var btn = document.getElementById("post-button");

            // Get the <span> element that closes the modal
            var span = document.getElementsByClassName("close")[0];

            // When the user clicks the button, open the modal 
            btn.onclick = function() {
                modal.style.display = "block";
            }

            // When the user clicks on <span> (x), close the modal
            span.onclick = function() {
                modal.style.display = "none";
            }

            // When the user clicks anywhere outside of the modal, close it
            window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
            }
        }

        ModalContainer();
    </script>
    <!-- <script src="https://maps.googleapis.com/maps/api/js?key=&callback=initMap&v=weekly" async defer ></script> -->
</body>
</html>